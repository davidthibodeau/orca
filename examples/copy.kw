syn tm where
| app: tm -> tm -> tm
| lam: (tm ->> tm) -> tm
| one : tm

lf tp where
| unit : tp
| arr : tp -> tp -> tp

syn oft : tm -> tp -> * where
| t-unit: oft one unit
| t-app: (f: tm) -> (e : tm) -> (s: tp) -> (t: tp)
         -> oft f (arr s t) -> oft e s -> oft (app f e) t
| t-lam: (s:tp) -> (t:tp) -> (e:tm ->> tm)
         -> ((x:tm) ->> oft x s ->> oft (e ' x) t) -> oft (lam (\x.e ' x)) (arr s t)

data isctx : (g:ctx) -> set where
| Empty : isctx \0
| Cons : (g:ctx) -> isctx g -> (t: |- tp) -> isctx (g, tm)

data lookup : (g : ctx) -> isctx g -> (g |- tm) -> (|- tp) -> set where
| is-here : (g:ctx) -> (G : isctx g) -> (t : |- tp)
          -> lookup (g, x:tm) (Cons g G t) (x:tm :> x) t
| is-there : (g:ctx) -> (G : isctx g) -> (t : |- tp) -> (m : (g |- tm)) -> (t' : |- tp)
          -> lookup g G m t -> lookup (g,x:tm) (Cons g G t') (m [ ^1 ]) t

data oft' (g:ctx) : isctx g -> (g |- tm) -> (|- tp) -> set where
| t-unit' : (G : isctx g) -> oft' g G one unit
| t-app' : (G : isctx g) -> (f : (g |- tm)) -> (e : (g |- tm)) -> (s : |- tp) -> (t : |- tp)
         -> oft' g G f (arr s t) -> oft' g G e s -> oft' g G (app f e) t
| t-lam'  : (G : isctx g) -> (e : (g, x:tm |- tm)) -> (s : |- tp) -> (t : |- tp)
          -> oft' (g, tp) (Cons g G s) e t -> oft' g G (lam (\x.e)) (arr s t)
| t-var : (G : isctx g) -> (e : (g |- tm)) -> (t : |- tp)
          -> lookup g G e t -> oft' g G e t

data step' (g : ctx) : (g |- tm) -> (g |- tm) -> set where
(*) | s-app1 : (m : tm) -> (m' : tm) -> (n : tm) -> step' m m' -> step' g (app m n) (app m' n)
| s-app1' : (m : (g |- tm)) -> (m' : (g |- tm)) -> (n : (g |- tm)) -> step' g m m' -> step' g (app m n) (app m' n)
| s-app2' : (m : (g,x:tm |- tm)) -> (n : (g |- tm)) -> step' g (app (lam (\x. m)) n) (m [ ^0 ; n ])
(*) | s-app2' : (m : tm) -> (n : tm) -> step' g (app (lam (\x. m)) n) (m [ ^0 ; n ])

syn step : tm -> tm -> * where
| s-app1 : (m : tm) -> (n : tm) -> (m' : tm) -> step (app m n) (app m' n)
| s-app2 : (m : tm ->> tm) -> (n : tm) -> step (app (lam (\x.m ' x)) n) (m ' n)

def copy : (g : ctx) -> (g |- tm) -> (g |- tm) where
| g one => one
| g (app M N) => app (copy g M) (copy g N)
| g (lam (\x. M)) => lam (\x. copy (g, tm) M)
| g (<:x) => x

def copy-oft : (g : ctx) -> (m : (g |- tm)) -> (t : (|- tp)) -> (g |- oft m (t[^])) ->  (g |- oft m (t[^])) where
| g one unit t-unit => t-unit
| g (app f e) t (t-app .f .e (s[^]) .(t[^]) d1 d2) =>
  t-app f e s[^] t[^] (copy-oft g f (arr s t) d1) (copy-oft g e s d2)
| g m t d => d

(*) Negative test case


(*) def test1 : nat -> nat where
(*) | (<: x) => x